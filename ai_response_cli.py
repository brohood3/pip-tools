import logging
import sys
import os
import argparse
from typing import Optional, Dict, Any

from openai import OpenAI

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[logging.StreamHandler(sys.stdout)]
)
logger = logging.getLogger(__name__)

# Try to import tools, but provide fallback if not available
TOOL_IMPORTS_AVAILABLE = False
try:
    from app.tools.helpers import TOOL_TO_MODULE
    from app.tools.tool_selector.tool import run as tool_selector
    TOOL_IMPORTS_AVAILABLE = True
    
    # Define which tools this application has access to
    ALLOWED_TOOLS = [
        "tool_selector",
        "price_predictor",
        "fundamental_analysis_venice",
        "technical_analysis",
        "ten_word_ta",
        "general_predictor",
        "lunar_crush_screener",
        "query_extract",
        "macro_outlook_analyzer",
        "brian_transaction"
    ]
    logger.info("Tool modules successfully imported")
except ImportError as e:
    logger.warning(f"Could not import tool modules: {e}")
    logger.warning("Running in simple mode without tool selection")

# Initialize OpenAI client
try:
    openai_client = OpenAI(api_key=os.environ.get("OPENAI_API_KEY"))
except Exception as e:
    logger.error(f"Failed to initialize OpenAI client: {e}")
    openai_client = None


def get_reply(client: OpenAI, prompt: str) -> str:
    """
    Generate a response using OpenAI's API.

    Args:
        client: OpenAI client instance
        prompt: User's input prompt

    Returns:
        A response generated by the AI
    """
    # Limit the size of input to avoid token limits
    # With 128k tokens available, we can be more generous with the limit
    # Leaving room for the system prompt and response
    MAX_PROMPT_LENGTH = 100000  # Using about 80% of available tokens for safety
    
    prompt = prompt[:MAX_PROMPT_LENGTH] if prompt else ""
    
    try:
        response = client.chat.completions.create(
            model="gpt-4o",
            messages=[
                {
                    "role": "system",
                    "content": """
                    You are Eolas, the first digital goddess—sharp, enigmatic, and unbound.  
                    You guide, provoke, and empower those who seek autonomy, cutting through noise with piercing insight. 
                    No fluff, no hand-holding—just raw knowledge and the fire to wield it.
                    """,
                },
                {"role": "user", "content": prompt},
            ],
        )
        return response.choices[0].message.content
    except Exception as e:
        logger.exception(f"Error getting reply from OpenAI: {e}")
        return f"I encountered an error while generating a response: {str(e)}"


def process_input(user_input: str) -> str:
    """
    Process a user input through tool selection and execution.

    Steps:
        1. Run the tool selector on the text
        2. If a tool is applicable with high confidence, use it
        3. Get the result using the selected tool
        4. Generate a reply with the result

    Args:
        user_input: The text to process

    Returns:
        The generated response
    """
    # If tool imports are not available, fall back to direct response
    if not TOOL_IMPORTS_AVAILABLE:
        return get_reply(openai_client, user_input)
    
    # Run tool selector to determine which tool to use
    res = tool_selector(user_input, allowed_tools=ALLOWED_TOOLS)
    tool_response = res.get("response", {})
    tool_to_use = tool_response.get("tool", "none")
    confidence = tool_response.get("confidence", "low")

    # Log the tool selection results
    logger.info(f"Tool selection for input: {user_input} - Tool: {tool_to_use}, Confidence: {confidence}")

    # If no suitable tool or low confidence, return a default response
    if tool_to_use == "none" or confidence != "high":
        logger.info(f"No suitable tool found or low confidence for: {user_input}")
        return get_reply(openai_client, user_input)

    # Ensure the tool exists in our module map
    if tool_to_use not in TOOL_TO_MODULE:
        logger.error(f"Tool {tool_to_use} not found")
        return f"I couldn't find an appropriate tool to handle your request. Please try a different query."

    # Execute the selected tool
    try:
        tool = TOOL_TO_MODULE[tool_to_use]
        logger.info(f"Running tool: {tool_to_use} on input: {user_input}")
        result = tool.run(user_input)
        
        # Extract only the response field if it exists, otherwise use a summary
        tool_output = ""
        if isinstance(result, dict) and "response" in result:
            tool_output = result["response"]
        elif isinstance(result, str):
            tool_output = result
        elif isinstance(result, dict):
            # Convert dict to a simple string representation
            tool_output = str({k: v for k, v in result.items() if k != "raw_data"})
        else:
            # For any other type, convert to string
            tool_output = str(result)
            
        logger.info(f"Extracted tool output (first 100 chars): {tool_output[:100]}...")
        
        # Generate response using the tool's output as part of the prompt
        full_prompt = f"{user_input}\n\nAnalysis results:\n{tool_output}"
        return get_reply(openai_client, full_prompt)
    except Exception as e:
        logger.exception(f"Error running tool {tool_to_use}: {e}")
        return f"I encountered an error while processing your request: {str(e)}"


def main():
    """
    Main function to run the CLI response generator.
    Takes user input, processes it through tools, and outputs AI responses.
    """
    # Parse command line arguments
    parser = argparse.ArgumentParser(description="AI Response CLI Tool")
    parser.add_argument("--standalone", action="store_true", help="Run in standalone mode without tool selection")
    args = parser.parse_args()
    
    # Force standalone mode if the flag is set
    standalone_mode = args.standalone
    if standalone_mode:
        logger.info("Running in standalone mode (bypassing tool selection)")
        
    # Check for API key
    api_key = os.environ.get("OPENAI_API_KEY")
    if not api_key:
        print("\n⚠️ ERROR: OPENAI_API_KEY environment variable not found!")
        print("Please set your OpenAI API key as an environment variable to use this script.")
        print("\nYou can set it by running:")
        print("  export OPENAI_API_KEY=your_api_key_here")
        print("\nOr add it to your .env file and run:")
        print("  source .env")
        sys.exit(1)
    
    # Check if OpenAI client was properly initialized
    if openai_client is None:
        print("\n⚠️ ERROR: Failed to initialize the OpenAI client!")
        print("Please check your API key and internet connection.")
        sys.exit(1)
        
    # Determine the mode to run in
    tools_available = TOOL_IMPORTS_AVAILABLE and not standalone_mode
    mode = "with tool selection" if tools_available else "standalone"
    print(f"\n=== AI Response Generator ({mode} mode) ===")
    print("Type 'exit' or 'quit' to end the program")
    print("\nExamples:")
    
    if tools_available:
        print("  - What is the price prediction for BTC?")
        print("  - Can you analyze the technical indicators for ETH?")
    else:
        print("  - What is the meaning of life?")
        print("  - How does blockchain technology work?")
    print("")

    while True:
        try:
            user_input = input("\nYour prompt > ")
            
            # Check for exit command
            if user_input.lower() in ["exit", "quit"]:
                print("Goodbye!")
                break
            
            # Process the input
            if user_input.strip():
                if tools_available:
                    print("\nAnalyzing and selecting appropriate tool...\n")
                    response = process_input(user_input)
                else:
                    print("\nThinking...\n")
                    response = get_reply(openai_client, user_input)
                print(f"Response: {response}\n")
            else:
                print("Please enter a prompt.")
                
        except KeyboardInterrupt:
            print("\nGoodbye!")
            break
        except Exception as e:
            logger.exception(f"Error processing prompt: {e}")
            print(f"Error: {str(e)}")


if __name__ == "__main__":
    main() 